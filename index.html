# bot.py
# Bot RPG del Lobo para Telegram - VersiÃ³n completa para Replit / hosting
# Usa python-telegram-bot v20+ (en Replit instalar con Packages)

import logging
import random
import os
from typing import Dict

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
)

# ConfiguraciÃ³n de logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# -------------------------------
# CLASE LOBO (versiÃ³n simplificada y completa)
# -------------------------------
class Lobo:
    def __init__(self, nombre="Lobo Sin Nombre"):
        self.nombre = nombre
        self.vida = 100
        self.vida_max = 100
        self.hambre = 0
        self.fuerza = 10
        self.velocidad = 10
        self.orbes = 0
        self.armadura = "Ninguna"
        self.dias = 0

    def pasar_dia(self):
        self.hambre += random.randint(8, 15)
        if self.hambre > 100:
            self.hambre = 100
            dano = random.randint(5, 12)
            self.vida -= dano

    def estado_texto(self):
        armadura_info = f"ğŸ›¡ï¸ {self.armadura}" if self.armadura != "Ninguna" else "Sin armadura"
        return (
            f"ğŸº *{self.nombre}* - DÃ­a {self.dias}\n\n"
            f"â¤ï¸ Vida: {self.vida}/{self.vida_max}\n"
            f"ğŸ– Hambre: {self.hambre}/100\n"
            f"ğŸ’ª Fuerza: {self.fuerza}   âš¡ Velocidad: {self.velocidad}\n"
            f"âœ¨ Orbes: {self.orbes}/60\n"
            f"{armadura_info}"
        )


# -------------------------------
# ESTADOS DE JUEGO POR USUARIO
# -------------------------------
users_game: Dict[int, dict] = {}  # user_id â†’ {"lobo": Lobo, "state": str}


# -------------------------------
# TECLADOS
# -------------------------------
def main_menu_keyboard():
    keyboard = [
        [InlineKeyboardButton("ğŸŒ² Explorar", callback_data="explorar")],
        [InlineKeyboardButton("ğŸ‡ Cazar conejo", callback_data="cazar_conejo")],
        [InlineKeyboardButton("ğŸ¦Œ Cazar ciervo", callback_data="cazar_ciervo")],
        [InlineKeyboardButton("ğŸï¸ RÃ­o (beber/descansar)", callback_data="rio")],
        [InlineKeyboardButton("ğŸ•¯ï¸ Santuario (deseos)", callback_data="santuario")],
        [InlineKeyboardButton("ğŸ“Š Estado", callback_data="estado")],
        [InlineKeyboardButton("âŒ Salir del juego", callback_data="salir")]
    ]
    return InlineKeyboardMarkup(keyboard)


# -------------------------------
# COMANDOS PRINCIPALES
# -------------------------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name

    if user_id not in users_game:
        lobo = Lobo(f"{username}'s Lobo")
        users_game[user_id] = {"lobo": lobo, "state": "menu"}
        await update.message.reply_text(
            f"Â¡Bienvenido al bosque salvaje, {update.effective_user.first_name}! ğŸº\n\n"
            "Tu leyenda comienza ahora...\n\n"
            "Usa los botones para decidir tu destino.",
            reply_markup=main_menu_keyboard()
        )
    else:
        await update.message.reply_text(
            "Tu lobo ya estÃ¡ en el bosque... continuemos la aventura.",
            reply_markup=main_menu_keyboard()
        )


# -------------------------------
# MANEJADOR DE BOTONES
# -------------------------------
async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    user_id = query.from_user.id
    data = query.data

    if user_id not in users_game:
        await query.edit_message_text("Usa /start para comenzar tu aventura.")
        return

    game = users_game[user_id]
    lobo: Lobo = game["lobo"]

    lobo.pasar_dia()  # Cada acciÃ³n avanza un dÃ­a
    lobo.dias += 1

    texto = ""

    if data == "estado":
        texto = lobo.estado_texto()

    elif data == "explorar":
        texto = "Exploras el bosque profundo...\n"
        if random.random() < 0.012:  # ~1.2% chance de orbe
            lobo.orbes += 1
            texto += "Â¡Un **orbe mÃ­stico** brilla entre las raÃ­ces!\n"
        else:
            texto += random.choice([
                "Solo encuentras hojas y silencio...",
                "Escuchas aullidos lejanos...",
                "Un ciervo pasa corriendo, pero no lo alcanzas.",
                "Encuentras restos frescos... +10 hambre recuperada",
            ])
            if "restos" in texto:
                lobo.hambre = max(0, lobo.hambre - 10)

    elif data == "cazar_conejo":
        if random.random() < 0.72 + (lobo.velocidad * 0.012):
            recuperacion = random.randint(18, 35)
            lobo.hambre = max(0, lobo.hambre - recuperacion)
            texto = f"Â¡Conejo cazado! Recuperas {recuperacion} de hambre."
        else:
            texto = "El conejo fue mÃ¡s rÃ¡pido que tÃº..."

    elif data == "cazar_ciervo":
        prob = 0.35 + (lobo.fuerza * 0.018)
        if random.random() < prob:
            recuperacion = random.randint(65, 110)
            lobo.hambre = max(0, lobo.hambre - recuperacion)
            texto = f"Â¡Ciervo abatido! +{recuperacion} hambre"
            if random.random() < 0.15:
                lobo.orbes += 1
                texto += "\nÂ¡Y un orbe aparece entre los restos!"
        else:
            dano = random.randint(18, 40)
            lobo.vida -= dano
            texto = f"El ciervo te hiriÃ³... pierdes {dano} vida"

    elif data == "rio":
        lobo.hambre = max(0, lobo.hambre - 15)
        recuperacion_vida = random.randint(10, 25)
        lobo.vida = min(lobo.vida_max, lobo.vida + recuperacion_vida)
        texto = f"Bebes agua fresca y descansas...\n-15 hambre, +{recuperacion_vida} vida"

    elif data == "santuario":
        if lobo.orbes >= 60:
            texto = "Â¡Con 60 orbes invocas el deseo legendario!\n\n"
            texto += "La Armadura Legendaria aparece ante ti...\n"
            texto += "+180 vida mÃ¡xima, +gran protecciÃ³n"
            lobo.armadura = "Legendaria"
            lobo.vida_max += 180
            lobo.vida = lobo.vida_max
            lobo.orbes -= 60
        elif lobo.orbes >= 10:
            texto = "Invocas el deseo Ã©pico...\n\n"
            texto += "Â¡Armadura Ã‰pica obtenida!\n"
            texto += "+80 vida mÃ¡xima"
            lobo.armadura = "Ã‰pica"
            lobo.vida_max += 80
            lobo.vida = lobo.vida_max
            lobo.orbes -= 10
        else:
            texto = f"El Santuario espera tu ofrenda...\nNecesitas al menos 10 orbes.\nTienes: {lobo.orbes}"

    elif data == "salir":
        if user_id in users_game:
            del users_game[user_id]
        await query.edit_message_text(
            "Abandonaste el bosque... tu lobo espera tu regreso.\n\n"
            "Usa /start cuando quieras volver."
        )
        return

    # Chequeo de muerte
    if lobo.vida <= 0:
        texto = "â˜ ï¸ Tu lobo ha muerto...\n\nLa naturaleza reclamÃ³ tu espÃ­ritu.\n\nUsa /start para crear una nueva leyenda."
        if user_id in users_game:
            del users_game[user_id]

    await query.edit_message_text(
        texto + "\n\n" + lobo.estado_texto(),
        parse_mode="Markdown",
        reply_markup=main_menu_keyboard()
    )


# -------------------------------
# INICIO DEL BOT
# -------------------------------
def main():
    # Obtener token desde variables de entorno (mejor para Replit)
    TOKEN = os.getenv("TOKEN")
    if not TOKEN:
        print("ERROR: No se encontrÃ³ el TOKEN en las variables de entorno.")
        print("En Replit: ve a Tools â†’ Secrets â†’ agrega TOKEN = tu_token_real")
        return

    application = Application.builder().token(TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(button_handler))

    print("Bot iniciado... esperando mensajes")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
